"""
UDF Generator - 使用 Copilot 生成 ANSYS Fluent UDF
"""

import os
from typing import Dict, Optional, List
from pathlib import Path
from loguru import logger

from .copilot_bridge import CopilotBridge


class UDFGenerator:
    """UDF 代码生成器"""
    
    # UDF 模板
    UDF_HEADER = """#include "udf.h"

/* 
 * Generated by Fluent-Copilot Integration
 * Description: {description}
 */

"""
    
    UDF_TYPES = {
        "profile": "DEFINE_PROFILE",
        "property": "DEFINE_PROPERTY",
        "source": "DEFINE_SOURCE",
        "adjust": "DEFINE_ADJUST",
        "execute_at_end": "DEFINE_EXECUTE_AT_END",
        "on_demand": "DEFINE_ON_DEMAND",
        "init": "DEFINE_INIT",
        "cg_motion": "DEFINE_CG_MOTION",
        "diffusivity": "DEFINE_DIFFUSIVITY",
        "heat_flux": "DEFINE_HEAT_FLUX",
        "turbulent_viscosity": "DEFINE_TURBULENT_VISCOSITY"
    }
    
    def __init__(self, copilot_bridge: Optional[CopilotBridge] = None):
        """
        初始化 UDF Generator
        
        Args:
            copilot_bridge: CopilotBridge 实例
        """
        self.copilot = copilot_bridge or CopilotBridge()
        logger.info("UDFGenerator initialized")
    
    def generate_udf(
        self, 
        description: str,
        udf_type: str = "profile",
        function_name: str = "custom_udf",
        include_comments: bool = True,
        context: Optional[List[str]] = None
    ) -> str:
        """
        生成 UDF 代码
        
        Args:
            description: UDF 功能描述
            udf_type: UDF 类型 (profile, source, adjust, etc.)
            function_name: 函数名称
            include_comments: 是否包含注释
            context: 上下文代码
            
        Returns:
            生成的 UDF 代码
        """
        logger.info(f"Generating UDF: {function_name} ({udf_type})")
        
        if udf_type not in self.UDF_TYPES:
            logger.error(f"Unknown UDF type: {udf_type}")
            raise ValueError(f"Unknown UDF type: {udf_type}. Available types: {list(self.UDF_TYPES.keys())}")
        
        # 构建提示词
        macro = self.UDF_TYPES[udf_type]
        prompt = self._build_udf_prompt(description, udf_type, macro, function_name)
        
        # 生成代码
        try:
            udf_body = self.copilot.generate_code(
                prompt=prompt,
                language="c",
                context=context
            )
            
            # 组装完整 UDF
            header = self.UDF_HEADER.format(description=description)
            full_udf = self._assemble_udf(header, udf_body, include_comments)
            
            logger.success(f"UDF generated: {len(full_udf)} characters")
            return full_udf
            
        except Exception as e:
            logger.error(f"Failed to generate UDF: {e}")
            raise
    
    def _build_udf_prompt(
        self, 
        description: str, 
        udf_type: str, 
        macro: str,
        function_name: str
    ) -> str:
        """构建 UDF 生成提示词"""
        prompt = f"""Generate an ANSYS Fluent User-Defined Function (UDF) in C with the following specifications:

Type: {udf_type}
Macro: {macro}
Function Name: {function_name}
Description: {description}

Requirements:
1. Include proper UDF.h header
2. Use the {macro} macro correctly
3. Follow ANSYS Fluent UDF coding standards
4. Include proper variable declarations
5. Add thread and cell loop macros where appropriate
6. Handle boundary conditions correctly
7. Include error checking

Generate only the UDF function body, not the header includes.
"""
        return prompt
    
    def _assemble_udf(self, header: str, body: str, include_comments: bool) -> str:
        """组装完整的 UDF 文件"""
        # 清理生成的代码
        body = self._clean_generated_code(body)
        
        # 如果代码中已经有 #include，去掉 header
        if "#include" in body:
            return body
        
        # 否则添加 header
        return header + body
    
    def _clean_generated_code(self, code: str) -> str:
        """清理生成的代码"""
        # 移除 markdown 代码块标记
        code = code.replace("```c", "").replace("```C", "").replace("```", "")
        
        # 移除多余的空行
        lines = code.split("\n")
        cleaned_lines = []
        prev_empty = False
        
        for line in lines:
            if line.strip() == "":
                if not prev_empty:
                    cleaned_lines.append(line)
                prev_empty = True
            else:
                cleaned_lines.append(line)
                prev_empty = False
        
        return "\n".join(cleaned_lines)
    
    def save_udf(self, code: str, file_path: str) -> bool:
        """
        保存 UDF 到文件
        
        Args:
            code: UDF 代码
            file_path: 文件路径
            
        Returns:
            是否成功保存
        """
        logger.info(f"Saving UDF to: {file_path}")
        
        try:
            # 创建目录
            Path(file_path).parent.mkdir(parents=True, exist_ok=True)
            
            # 保存文件
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(code)
            
            logger.success(f"UDF saved to {file_path}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to save UDF: {e}")
            return False
    
    def generate_common_udfs(self, output_dir: str = "udfs") -> Dict[str, str]:
        """
        生成常用 UDF 示例
        
        Args:
            output_dir: 输出目录
            
        Returns:
            生成的 UDF 文件字典
        """
        logger.info("Generating common UDF examples...")
        
        common_udfs = {
            "parabolic_velocity_profile.c": {
                "description": "Parabolic velocity profile at inlet",
                "type": "profile"
            },
            "custom_source_term.c": {
                "description": "Custom source term for momentum equation",
                "type": "source"
            },
            "temperature_dependent_viscosity.c": {
                "description": "Temperature-dependent viscosity property",
                "type": "property"
            },
            "custom_initialization.c": {
                "description": "Custom field initialization",
                "type": "init"
            }
        }
        
        generated_files = {}
        
        for filename, spec in common_udfs.items():
            try:
                code = self.generate_udf(
                    description=spec["description"],
                    udf_type=spec["type"],
                    function_name=filename.replace(".c", "")
                )
                
                file_path = os.path.join(output_dir, filename)
                if self.save_udf(code, file_path):
                    generated_files[filename] = file_path
                    
            except Exception as e:
                logger.error(f"Failed to generate {filename}: {e}")
        
        logger.success(f"Generated {len(generated_files)} UDF examples")
        return generated_files
    
    def validate_udf(self, code: str) -> Dict[str, any]:
        """
        验证 UDF 代码
        
        Args:
            code: UDF 代码
            
        Returns:
            验证结果
        """
        logger.info("Validating UDF code...")
        
        result = {
            "valid": True,
            "errors": [],
            "warnings": []
        }
        
        # 检查必要的包含
        if "#include \"udf.h\"" not in code and "#include <udf.h>" not in code:
            result["errors"].append("Missing #include \"udf.h\"")
            result["valid"] = False
        
        # 检查是否有 DEFINE_ 宏
        has_define = any(udf_type in code for udf_type in self.UDF_TYPES.values())
        if not has_define:
            result["warnings"].append("No DEFINE_ macro found")
        
        # 检查基本语法
        open_braces = code.count("{")
        close_braces = code.count("}")
        if open_braces != close_braces:
            result["errors"].append(f"Mismatched braces: {open_braces} open, {close_braces} close")
            result["valid"] = False
        
        logger.info(f"Validation complete: {'PASS' if result['valid'] else 'FAIL'}")
        return result
